### Problem Statement
Given a positive number of cells $N$, construct a staircase with $n$ columns where the $i$-th column has exactly $i$ cells. The image below shows how a staircase might look:

![](https://espresso.codeforces.com/610714b89a9be1f8123f88bbd3c47f42f3b448da.png)

A staircase is **nice** if its cells can be tiled by $n$ disjoint squares. Find the maximum number of nice staircases that you can form using a total of $N$ cells.

**Constraints:** $1 \le N \le 10^{18}$

**Link:** [Codeforces 1419B - Stairs](https://codeforces.com/problemset/problem/1419/B)

---

### Quick Takeaway
Observe small examples to find a pattern. Try to express the observations mathematically to form an axiom. Construct a proof using standard techniques (contradiction, induction, etc.).

---

### Intuition
A staircase with $n$ columns is nice if $n$ is of the form $2^k - 1$ where $k$ is some positive integer. A staircase with $n$ columns requires $\frac{n(n+1)}{2}$ cells. To maximize the number of nice staircases, greedily construct the smallest ones first ($k=1, 2, 3, \dots$).

---

### Formal Proof

#### Definitions
Let $S_n$ be the staircase region with $n$ columns, where column $c$ has height $c$ (cells $(r,c)$ for $1 \le r \le c \le n$).

A **square** of side $s$ is a set of cells:
$$Q = \{(r,c) \mid a \le r \le a+s-1,\; b \le c \le b+s-1\}$$
A square is **valid** if $Q \subseteq S_n$.

Let $f(n)$ be the minimum number of disjoint valid squares whose union is exactly $S_n$. A staircase $S_n$ is **nice** iff $f(n) = n$.

---

#### Part A — Lower Bound: $f(n) \ge n$

##### Lemma A1 (Top cells are “separated”)
Define the **top cell** of column $c$ as $T_c := (c,c)$. No valid square can contain two distinct top cells $T_i$ and $T_j$ for $i < j$.

**Proof:**  
If a square contains both $(i,i)$ and $(j,j)$, then by axis-aligned rectangularity it must also contain $(j,i)$. However, $(j,i) \notin S_n$ since $j > i$ violates the staircase condition $r \le c$. $\square$

**Corollary:**  
Each square contains at most one top cell. Since there are $n$ top cells, any tiling needs at least $n$ squares: $f(n) \ge n$. To be nice ($f(n) = n$), every square must contain **exactly one** top cell.

---

#### Part B — Structure: If $S_n$ is nice, $n$ must be $2^k - 1$

##### Lemma B1 (The bottom-right square is forced)
Let $B := (1,n)$ be the bottom-right cell. In any nice tiling of $S_n$, the square $Q$ that contains $B$ has side length $s = \frac{n+1}{2}$.

**Proof:**  
1. **Validity constraint:** Leftmost column $c_{min} = n-s+1$. Height requirement: $s \le c_{min} \Rightarrow s \le \frac{n+1}{2}$.
2. **Nice-tiling constraint:** $Q$ must contain some top cell $(k,k)$. Thus $k \le s$ and $k \ge n-s+1 \Rightarrow s \ge \frac{n+1}{2}$.
Combining these, $s = \frac{n+1}{2}$, implying $n$ must be odd. $\square$

##### Lemma B2 (Recursive Splitting)
Removing the forced $s \times s$ square from the bottom-right corner of $S_n$ leaves two disjoint copies of $S_{s-1}$.

##### Lemma B3 (Nice $\Rightarrow$ Smaller Nice)
If $S_n$ is nice ($n>1$), then $n$ is odd and $S_{(n-1)/2}$ is also nice.
**Proof:** $f(n) = 1 + 2f(s-1) = n$. Since $2s-1=n$, we have $f(s-1)=s-1$. $\square$

---

### Theorem (Characterization)
A staircase $S_n$ is nice **iff** $n = 2^k - 1$ for some integer $k \ge 1$.

---

### Part C — Greedy is Optimal
A staircase of size $n=2^k-1$ contains:
$$|S_{2^k-1}| = \frac{(2^k-1) \cdot 2^k}{2} = (2^k-1) \cdot 2^{k-1}$$
Since these costs strictly increase with $k$, the "cheapest-first" greedy strategy is optimal for maximizing the number of staircases within budget $N$.

---

### Code
```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);

    int test;
    cin >> test;

    const auto getCells = [](long long n) {
        return n * (n + 1) / 2;
    };

    while (test--) {
        long long totalCells;
        cin >> totalCells;

        int res = 0;
        long long nextN = 2, cellsUsed = 0;

        while (true) {
            long long currentStaircaseCells = getCells(nextN - 1);
            if (totalCells - cellsUsed < currentStaircaseCells) break;
            
            ++res;
            cellsUsed += currentStaircaseCells;
            
            // Check for overflow before doubling
            if (nextN > (1LL << 30)) break; 
            nextN *= 2;
        }

        cout << res << "\n";
    }
}
```
